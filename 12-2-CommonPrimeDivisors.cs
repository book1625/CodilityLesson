using System;
using System.Collections.Generic;
using System.Linq;

namespace Codility
{
	/*
     * https://codility.com/programmers/lessons/12-euclidean_algorithm/common_prime_divisors/
     * 
     * 給你一對數組，問你每組數字有沒有具相同的質因數集合，回答有幾組是相同的
     * 
     * 我的回想只到最後一動前卡住，可惜了，我已經來到用 gcd 把數字先砍掉，來到了 restA and restB 的階段
     * 但由於我不知道怎麼決定 restA 和 gcd 間具有相同的質因數成份而卡住
     * 這裡缺的想法是，如果 restA 可以完全以 gcd 的成份來寫出來，那它一直和 gcd 再取一次 gcd 來除掉自已，最終只會剩下 1
     * 如果取到 gcd 都變 1了還是沒辦法把自己洗成1，那表示自己還有別的質因數成份存在，那就表示 restA 和 restB 有不同的質因數成份了
     * 因為如果同，就會被拉到原始的 gcd 裡面...
    */
	public class CommonPrimeDivisors
    {

		/*
         * 演算法思路
         * 一。一開始的版本基本上就是 brute-force ....
         * 就只使用了取因數來暴是比對是不夠快的…
         * 它應該有數學上的技巧
         * 
         * 還是說明一下：想法是，如果我能找到指定數字的所有因數，然後取 xor 
         * 這個集合如果沒半個質數，那這一對數字的所有質因數就被約分了，自然他們也得長的完全一樣…
         * 但是，判斷質數在某些大數字時是很可怕的
         * 首先，要查的快就得建質數表，但這題你建不起，因為輸入的 n 可以是 max int
         * 就算不管題目限制你 O(1) 的空間，你也沒有足夠的記憶體把所有 int 是不是質數給列出來
         * 所以下次碰到這種就別這麼想了…
         * 題目可能給你幾萬個 max int (它是質數) 所以你就算一個可以算一輪，也算到死
         * 質數的加速在這種例子上沒有用…(先偷除 2 和 3)
         * 
         * 這個寫法，不小心碼刪光了，反正只有取 xor 是新學的，查一下就有了…
         * 
         * 
         * ====================================================================
         * 
         * 所以還是要回到數學上…，偷看人家解法，是用到 gcd 的…
         * 在沒有數學的支持下，我只能用猜的，gcd 到底作啥用，所以我找了兩個數，列出所有因數
         * 我發現，在 gcd 之後，只要沒有質數，看起來就很像對的，而且我很容易就創出一個 gcd 之有相異質的版本
         * 這時我不禁要猜，難道 gcd 以前的集合，一定會有相同的質因數集合 ????
         * 如果是這樣，我是不是只要看比 gcd 大的值就好…
         * 結果這個想法果然沒依據，因為  10 ，30 就是一個反例，在 gcd 10 之前的質因數集合不一樣
         * 
         * 這裡要先學會數學上的幾件事
         * 一。正整數可以被寫成質因數表示法->多個可重覆的質因數連乘-> 取不重覆就是質因數集合 
         * 二。兩個數的 gcd 可以由他們的共同質因數集合乘出來!!!!! 這是關鍵
         * 64 = 2*2*2*2*2*2
         * 48 = 2*2*2*2*3
         * 所以最大公因數16 = 2*2*2*2
         *  
         * 所以如果把值拿去除 gcd
         * 64/16 = 2*2
         * 48/16 = 3
         * 則這兩個剩的數，不會有共同的質因數，所以最大公因數1
         * 而最大公因數，則掌握了所有共同質因數的部份
         * 
         * 我們想要的目標是，這個剩下來的數不是質數，如果兩者有任一者是質數，則表示這兩個數不具有相同的質因數集合
         * 
         * 但這時候算質數，還是死路，因為會遇到正很大的質數…，沒辦法靠最大公因數減重
         * 所以要想辦法再把這兩個值變的更小
         * 
         * 如果把這兩個數對原本的公因數取 gcd 得到非1 ，表示這兩個數與原本的公因數間，有共同的質因數部份
         * 由於這些質因數，我們已經在最大公因數時看過了，也算在我們的集合裡，所以可以進一步無視它，
         * 因為我們關心的是有沒有不共同的部份
         * 
         * 所以，只要減重過的值與 gcd 再取最大公因數不為1，就可以再減一次
         * 這個過程，要一直減到剩下的值與最大公因數間，不再具有共同的質因數(取 gcd = 1)
         * 這時才是減到了極限…
         * 這個過程，我將它稱為，「把看過的質因數，從剩下來的值先進一步拿掉」
         * 
         * 如果剩下來的值還具有非 1 的質因數，那很明顯的這兩個數沒辦法擁有相同的質因數集合
         * 如果你實際運作一下，會發現，當你把質因數一直用這種方法除掉時，你除到最後只會有兩種情況
         * 一。只剩1
         * 二。只剩一堆沒看過的質因數連乘，而且兩個剩下的數所得到的質因數連乘完全不重覆，有交集早被列入最大公因數
         * 
         * 很明顯，我們要的就是 1…
         * 
         * 這個過程，完全不用求質數，不用求所有因數… 
         * 
         * 用兩個數字的變化來說明上面的流程
         * 
         * a = 2*2*2*3*5*7
         * b = 2*3*3*3*11
         * 
         * 先找出 gcd = 2*3
         * 
         * 2*3 *2*2*5*7
         * 2*3 *3*3*11
         * 
         * 第一輪
         * *2*2*5*7 -> *2*5*7
         * *3*3*11 -> *3*11
         * 第二輪
         * *2*5*7 -> *5*7 
         * *3*11 -> *11
         * 第三輪由於 GCD 都是1 而放棄
         * 
         * 結果很明顯，如果能全抽光，那兩數的質因數集合就是 GCD 的質因數集合
         * 如果抽不光，那必有不同的質因數存在，而且必不同
        */


		private int GCD(int a, int b)
		{
			//swap 寫了比較好被呼，外面不用管也沒差
			if (a < b)
			{
				int temp = a;
				a = b;
				b = temp;
			}

			if (a % b == 0)
			{
				return b;
			}
			else
			{
				//這裡由於 b%a 的餘數不可能大過 b ，所以可以保證
				//每次傳入時，前一個比較大
				return GCD(b, a % b);
			}
		}


        public int Solution(int[] A, int[] B)
        {
            int result = 0;
            for (int i = 0; i < A.Length;i++)
            {
                var gcd = GCD(A[i], B[i]);


                int tempA = A[i];
                int tempGcd = gcd;
                do
                {
                    tempA = tempA / tempGcd;
                    tempGcd = GCD(tempA, gcd);
                    
                } while (tempGcd != 1);

                int tempB = B[i];
				tempGcd = gcd;
				do
				{
					tempB = tempB / tempGcd;
					tempGcd = GCD(tempB, gcd);

				} while (tempGcd != 1);



                if( tempA == 1 && tempB == 1 )
                {
                    result++;
                }
            }

            return result;
        }
    }
}
