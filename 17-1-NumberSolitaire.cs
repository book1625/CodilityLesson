using System;
namespace Codility
{
	/*
     * https://codility.com/programmers/lessons/17-dynamic_programming/number_solitaire/
     * 
     * 給你一堆數字，你站在第一個位置上，然後開始丟骰子，可以走1-6步，站在上個位置上，直到走到最後一個位置，最後如果過頭就毃到有為止
     * 
     * 求所有站過的位置，它們的值加總可以最大
     * 
     * 想法：brute-forced 對於總數 n 取任意切割，每個切割有1-6個元素不等，然後計算切點的和為總值，取最小
     * 每個元素都可以是切點或不是 所以有 2**n，然後減掉超過六個必有一切點，所以會少一些，但…也少不到那裡去
     * 所以要到 O(n) 不是 greedy 就是 dp
     * 再來，由於一次最多跳六個，所以，每一個都只能從前六個跳過來，這點很有 dp 的味道
     * 所以如果有張表dp，索引是位置，值是跳到這個索引的最大總和，就可以直查
     * 然後 dp[n] = Max(dp[n-6 .. n-1] + A[n])
     * ya~~ 果然還記得~~
    */
	public class NumberSolitaire
    {
        /*
         * 演算法思路
         * 一。這題其實並不難，一開始就有利用 dp 想出來，每個新的元素，都是從過往最多六個元素跳過來的
         * 只要每個過往元素，都有記得他們能成立的最大和，那新的元素的最大和，就是這六個裡面選一個大的來和自已相加
         * 但，這個解法，上去之後0分，除了例子以外，其它都錯
         * 二。後來開始試不同的例子，發現我一開始在設六個元素取最大時，預設值是先設自已，也就是說，我考慮自已直接被跳到，和就是只有自已
         * 但這個想法也是錯的，因為除了前六個，其它都無法一次跳到
         * 三。所以，我又加了 if 在前六個時，考慮一次跳到的可能，但，還是0分…
         * 
         * 到這裡，我實在快要忍不住偷看答案了，但我還是再看一次題目好了…
         * 結果…
         * 他媽的，題目是預設你已經站在第0個位置了，也就是說，不管怎麼走，一定有經過 0 
         * 這時，我開始想怎麼在現行的演算法上，把0先無視掉
         * 所以，我試著把1當起點開始作，但很明顯答案不對… 我的想像是，0如果不存在，在選擇1~5時會有不同的版本出現，但我沒驗證它
         * 我試著把答案再手寫一次，結果發現，其實只有1這個位置是強制加上0，從2開始，你所有的往前選擇都會包含有經過0，所以不用刻意作
         * 這時程式就變單純了，從2開始，往前看最多六個，找最大的加上自己就好
         * 而且，由於 0 必走，原本處理直接跳到自己(在元素1~5)也變的沒有意義，定一從透過前面的人跳到我身上來才行，0也在選擇之中
         * 到此，直上100…
         * 
         * 
        */
        public int Solution(int[] A)
        {
            int len = A.Length;
            int[] dp = new int[len];
            dp[0] = A[0];
            dp[1] = A[0] + A[1];
 
			//我的最大，等於前六個人中的最大，選一個和我整合
			for (int i = 2; i < len; i++)
            {
                int tempMax = int.MinValue;

                int j = i - 1;
                while(j >= 0 && i - j <= 6)
                {
                    //Console.WriteLine("dp{3}={0} a{4}={1} temp={2}", dp[j], A[i], tempMax, j, i);
                    if(dp[j] + A[i]  > tempMax)
                    {
                        tempMax = dp[j] + A[i];
                    }
                    j--;
                }
                dp[i] = tempMax;
            }

            return dp[len - 1];
        }
    }
}
