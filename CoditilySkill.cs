/*


關於輸入資料方面=========================================================================

一。不管它你的值的多大，那你任何的運算都要考慮會不會爆，尤其是累計和乘法
二。如果輸入可以是 0個，一定要測到
三。如果值有上下界，一定要測上下界
四。一定要注意，如果是題目有指定在無法進行時的回傳值
五。要開快取陣列時，一定要考慮題目給的界限值，開 2**31 長的陣列是一點都不實際的…
六，一般他如果說超過某個值就回100000000，那表示，中間的累計數量一定有鬼，
   一定要用大的型別去「算」才不會算到後來溢位小回來，不然除錯會除不完的。
   long temp = (long) i * i ;  兩個 long 都不能省 !!!!! 死很多次了別再忘了

七。輸出如果被要求是陣列，更要注意是可以回空陣列，還回有指定元素 0 or -1 的陣列，千萬別亂傳
八。千萬不要丟例外，只要例外，分數就沒救了，因為正確度不行，效能判定也死

關於資料轉換方面=========================================================================

一。連續除2連二元陣列
二。把資料轉 HashSet 是過濾資料最快的方法，如果不需要發生次數的話
三。盡可能用數學式來取代掃一次，比方 sum = left + right  那你永遠只管 left 就好，靠 sum 就有 right




關於演算法=========================================================================

一。只要你的作法是小於題目的複雜度，多作幾次是沒差的，執行三四個O(N) 是不會高過 O(NlogN)的

二。演算限制通常也是在提醒你要考慮的因素，比如 O(n+m)，表示 m 的元素應該也是你演算法的迴圈，如果你沒考慮它的話…就不太對

三。 prefix sums https://codility.com/media/train/3-PrefixSums.pdf

這是一個很常出現的統計手段，它最強大的就是可以透過O(N)建立，然後任意點的「變化」都可以用一次減法來得到
所以除非你要記得所有變化的歷程，或是要退回某些步驟，不然它都可以派上用場
請記得，尾-頭 代表的是從 頭+1~尾的變化，不包含頭

四。Math 命名空間的幾個方法要會用 

max min divrem abs

五。Sort 的委派方法，是一個神奇的地方，因為只要能接受 nLogn，那你可以照自已的意願排資料

這樣很多事會變成O(n)算完，在絕對值的題就有這樣的解法

六。雙層迴圈的降階，可以參照 6-4 的解法，這種手段不只出現一次，可以把 n**2 降到 n or nlogn

它的原理是，在第二層的迴圈，不受第一層重置，每個第一層進來都只是把原有的第二層指標往前推，直到沒有
它的限制是，第二層的特性「必需」前面已作過的元素，可以直接判定全不符合或全符合，所以不用再重算一次，只要引用索引來得知數量就好

七。關於 stack and queue https://codility.com/media/train/5-Stacks.pdf

這兩個結構，C#都是內建的，不要笨笨自己來，很容易死在算索引，浪費時間
queue 一般都是拿來過資料，應用也不難想，所以，這裡著重來 stack
只要你需要回顧過去，然後又往前走，又得回顧，這種感覺，stack 就出來了
以 7-1 為例，你必需一路往前建置，又三不無時回頭吃幾塊石頭，又一路建新的，這就很像上面的描述
括號的題目只要出現，九成九是 stack 考題，因為括號的行為太像上面了，又要和最近的對稱，所以得往回對

八。關於 Leader https://codility.com/media/train/6-Leader.pdf

這個我以前沒有什麼印象，找過半的元素我應該也只會用掃的統計一次
它裡面有個用 stack 的解我覺很不錯要理解一下，所以就寫下來
leader 如果是過半元素，那它的特色就是，如果你其它非 leader 拿來和它配一對一，你剩下來的一定全是 leader
問題是，我不知道誰是 leader 啊，這就是巧妙的地方了，如果你每次都拿兩個不同的元素來配，管他是不是 leader
那你只有兩種可能，一是兩者有一個 leader，二兩者都不是 leader，前面一個沒問題是正常流程，後面這個更好了
連 leader 都沒有消到，剩下的更是 leader 才對…
如果你這樣消完，結果剩下某個元素，所以它就是 leader…嗎????
有一種可能是，所有元素前面都不同，只有最後兩個同，所以只留下最後，但它不是 leader
所以這個算法，只能找到「候選人」，但你可以用這個候選人去掃一次統計它的次數，驗證它是否是真正的 leader

九。關於 max slice https://codility.com/media/train/7-MaxSlice.pdf

暴力法n**3，你可以用 prefix sum 少掉算和 降 n**2 , 不用 prefix 也會發現和其實一直在累加，也不用真的重算，所以也是 n**2

重點其實是第三個解法 O(n) (Kadane's Algorithm )，這一型的問題，它都是問你最大或最小，說穿了，中間也不重要，只要你的下一動可以靠當前的最大或最小直接推到
如果我都知道 元素x 以前的最大和是 mx，則 元素 x+1 的最大和不就是在 [元素x最大和] + [元素x+1] 或 0 中，找一個大的留下
這個寫法要成立，有個很重要的基點是，這個記錄的最大和，在文件裡它叫 max ending，它代表的是，包含當前元素下，往前推連續元素可得的各種和裡
最大的一種，如果當前的元素被發現往前加到變負的，則當前的元素被視為的棄子，它斷開了原有的連續片段，重新開始，為何選 0 是最難理解的
如果你用一個全負數的陣列，你就會發現，你寧願選一個空集合回傳0，也不願選任何一個元素，因為題目有說
We assume that the slice can be empty and its sum equals 0
所以用0作為重來的區分，這點可能要看題目才能決定

這裡最重要的是就是上面說的，每一動都在記得曾經發生的最大或最小，而下一動可以靠前一動就決定，這時就要用這個算法!! (Kadane's Algorithm )
9-1是這個方法應用的細節，一定要看一次說明

十。關於 Prime https://codility.com/media/train/8-PrimeNumbers.pdf

質數的定義要先搞清楚，大於等於2，只有1和本身兩個因數
合數就是不只兩個因數
找因數最多查到 sqrt(n)，因數是成對的，所以不用查那麼遠
要查質數，直那就是從2查到 sqrt(n)，如果都沒整除，那就是質數，這樣還是貴，如果 n 很大
如果要加速查一堆，而且 n 沒有大的見鬼，那可以用從 2 ~ sqrt(n)，每個數的倍數都標記不是質數，這樣可以得到一張 n 表能正確的表達誰是質數
文件中那個翻硬幣的，如果你試著翻會發現，只有平方根會被奇數次，其它都是偶數次，為何，因為你在翻時，你就是每個被翻的硬幣的因數
而每個硬幣的因數，除了剛好平方根的是奇數外，其它都是偶數，也因此決定個數

十一。關於 Sieve https://codility.com/media/train/9-Sieve.pdf

Sieve 利用從小到大的質數去打掉所有後面的倍數(因為他們是合數)，走 sqrt(N) 步來保證 N 以內質數表有效
加強 Sieve 則是在打掉合數時，一口氣直接先跳平方步開始開打，可以看 11-0 的說明
同樣的 Sieve 流程，可以用來建一張 2..N 的最小可除質因數表，有了這張表，就可以在 O(N) 內作到 Factorize 質因數分解
基本上，手法就是一直查表，除個小質數把自己變小，再查變小的自己，直到不能除

十二。關於 Euclidean algorithm https://codility.com/media/train/10-Gcd.pdf

就是輾轉相除法，你除我得餘數，換我被你的餘數除，一直交叉，直到整除，最後整除的除數為最大公因數，O( log(a+b) )

十三。關於 Fibonacci https://codility.com/media/train/11-Fibonacci.pdf

十四。永遠都要站在小迴圈上去掃資料啊!!!!! 拿幾萬個 n 去確認是不是 fib 不如拿 fib 去看看手上的 n 合不合 (13-1的例子)

十五。binary search 請直接看 14-0 的說明比較快

只要有能找到點，就決定某半成功這種特質，它就適合 binary search 

十六。關於 Caterpillar https://codility.com/media/train/13-CaterpillarMethod.pdf

就像隻毛虫一樣的往前走，它的延伸概念就是上面那個利用作過不再作，可以降階一個迴圈
15-2 要多看幾次記下來，因為它的例子太容易被忽略，而選擇太容易的作法

十七。關於 Greedy https://codility.com/media/train/14-GreedyAlgorithms.pdf

Greedy 本身就不是為了找到最佳解而生的… 它就是求個可用的解, 目標都是把演算法壓到愈小愈好
如果有不同的 greedy 解法，還可以組合來再選一個較好的解，我在 17-2 就幹過這種事
把兩個 greedy 組合，結果得到 答案正確，效率80 合計90的成績
我認為 greedy 最大的難點是，我看到問題，怎麼知道要用 greedy 來解…??? 難道每次想不出來就 greedy ??
目前我推的出來的論點是，如果題目用暴力法，直接就是指數級的複雜度，那不太可能有什麼神乎奇技可以降階到O(n)
這時就要考慮用 Greedy 來冒險了，我在 16-1 16-2 都有寫下這些推論可以看

十八。Dynamic Programming https://codility.com/media/train/15-DynamicProgramming.pdf

dp 基本上就是把大問題拆成很像但規模變小的問題，然後從最小的一路組答案上來，很多求曾經最大最小的問題，都是這樣的
每次新的元素加入，就關心先前發生過的極值，與新元素帶入後的影響，所以新元素的dp的值，就是前元素的dp與新元素帶來的變化，進行某些運算後得到
dp 最難的就是，拿什麼來 dp，很多時候它都很神奇也難以想到

關於測試 =========================================================================

一。當然，界限值，空輸入，指定爆值回傳，這些都是要想辦法測的
二。題目得先看清楚，不然測半天卻將錯就錯，這種事太常發生，也太花時間
三。基於你的演算法，應該會有些演算法上的怪點要測，比如剛好等於，剛好在頭或在尾，這種事通常可以測得演算法的 bug
四。max int 的輸入一定要測，只要他有給，一般演算法一定會爆溢位


關於神奇的數學原理要背的… =========================================================================

一。如果你要找最小的平均數，那當數字有 n 個 a1,a2,.....an => (a1+a2+...an) / n
這時有個神奇的定理是 n 愈大,  你能得到的平均反而收斂… 只有 n <= 3 時可以找到最大平均，多了反而沒用

二。如果叫你湊三角型，有一個定理很重要 ~~ 絕對不是兩邊和大於第三邊

如果給定個數字 a <= b <= c 它們三個可以成為一個三角形，則，b 在 a ~ c 間任意移動，都一樣是個三角形
這點可以幫你很多算過的三角形就別再算
另外，如果不確定 abc 是一個三角形，但在 a ~ c 間找到一個 d 發現 abd 不是三角形
那就違反上面第一規則，abc 不會是個三角形，因為他們中間存在一個不是三角形的可能

三。每個數都可以寫出一道質因數分解 (Factorization 演算法，在上面的 sieve 裡面有)
兩個數共用的質因數分解區，為最大公因數
兩個數乘 除以 最大公因數 = 最小公倍數 (用質因數去看，就是把「一份最大公因數」乘上「兩數各自剩下的質因數」)
兩個數有沒有相同的質因數集合(就是質因數分解裡的質因數都一樣，只是次方不同)要如何判定?
兩者除以最大公因數後，剩下來的部份，必須能和最大公因數作到完全共質因數，所以剩下來的部份不斷和原gcd重取 gcd 用來除自己
把自己和 gcd 相同的部份消除，如果能成功的把自己完全消除，表示自己完全可以 原gcd 的質因數去表示，所以具有相同集合

四。如果叫你用 mod 來回答，一般就是資料超爆，只能存 mod，而 mod 有個重要的特性是
如果你把兩個數加起來 mod n ，其實等於兩個各自 mod n，加起來，再 mod n
另外，你如果需要 mod 2*p 次方， 你那可以先 mod 一個題目限制裡最大的版本，比如 2**30，這樣你的值就會在 0.. 2**30 -1 間
這樣你不管題目要 mod 2*p p<30 你都可以正常的再 mod 來求得

 */